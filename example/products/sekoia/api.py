from requests import HTTPError, Session

from .utils import exclude_nones


class SekoiaAPI(Session):
    """Client for the Sekoia.io API"""

    def __init__(self, region: str, api_key: str):
        super().__init__()
        self.headers.update({"Authorization": f"Bearer {api_key}"})
        region = region.lower()
        if region == "fra1":
            self.base_url = "https://api.sekoia.io"
        else:
            self.base_url = f"https://app.{region}.sekoia.io/api"

    def request(self, method, url: str, *args, **kwargs):
        url = self.base_url.strip("/") + "/" + url.strip("/")
        res = super().request(method, url, *args, **kwargs)
        try:
            res.raise_for_status()
        except HTTPError as e:
            raise ValueError(e.response.json())
        return res

    def create_intake_key(
        self,
        entity_uuid: str,
        format_uuid: str,
        name: str,
        connector_configuration: dict | None = None,
        connector_module_configuration_uuid: str | None = None,
    ):
        """Create an intake key for the given format"""
        return self.post(
            "/v1/sic/conf/intakes",
            json=exclude_nones(
                {
                    "entity_uuid": entity_uuid,
                    "format_uuid": format_uuid,
                    "name": name,
                    "connector_configuration": connector_configuration,
                    "connector_module_configuration_uuid": connector_module_configuration_uuid,
                }
            ),
        ).json()

    def delete_intake_key(self, uuid: str):
        """Delete an intake key given its UUID"""
        return self.delete(f"/v1/sic/conf/intakes/{uuid}")

    def get_intake_keys(self, name: str | None = None, format_uuid: str | None = None):
        """Return a page of intake keys"""
        return self.get(
            "/v1/sic/conf/intakes",
            params={
                "match[name]": name,
                "match[format_uuid]": format_uuid,
            },
        ).json()["items"]

    def get_entities(self):
        """Return a page of entities"""
        return self.get("/v1/sic/conf/entities").json()["items"]

    def get_or_create_main_entity(self, default_name: str = "Main Entity"):
        """Return the main entity or create it"""
        try:
            return sorted(self.get_entities(), key=lambda x: x["entity_id"])[0]
        except IndexError:
            return self.create_entity(default_name)

    def create_entity(
        self,
        name: str,
        entity_id: str | None = None,
        alerts_generation: str | None = None,
        description: str = "Generated by Meshroom",
    ):
        """Create a new entity"""
        entity_id = entity_id or name.lower().replace(" ", "_")
        alerts_generation = alerts_generation or self.get_generation_modes()[0]["uuid"]
        return self.post(
            "/v1/sic/conf/entities",
            json={
                "entity_id": entity_id,
                "description": description,
                "alerts_generation": alerts_generation,
                "name": name,
            },
        ).json()

    def get_generation_modes(self):
        """Return the available generation modes"""
        return self.get("/v1/sic/conf/generation-modes").json()["items"]

    def get_or_create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Return a default module configuration or create it for the given module UUID"""
        try:
            return self.get_module_configurations(module_uuid)[0]
        except IndexError:
            return self.create_module_configuration(module_uuid, name, settings)

    def get_module_configurations(self, module_uuid: str):
        """Return the module configurations for the given module UUID"""
        return self.get(
            "/v1/symphony/module-configurations",
            params={
                "match[module_uuid]": module_uuid,
                "with_module": "true",
            },
        ).json()["items"]

    def create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Create a new module configuration"""
        return self.post(
            "/v1/symphony/module-configurations",
            json={
                "name": "Default",
                "module_uuid": module_uuid,
                "value": settings,
            },
        ).json()
