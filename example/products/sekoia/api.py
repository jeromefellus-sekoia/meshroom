from pathlib import Path
from time import sleep
from requests import HTTPError, Session

from .utils import exclude_nones


class SekoiaAPI(Session):
    """Client for the Sekoia.io API"""

    def __init__(self, region: str, api_key: str):
        super().__init__()
        self.headers.update({"Authorization": f"Bearer {api_key}"})
        region = region.lower()
        if region == "fra1":
            self.base_url = "https://api.sekoia.io"
        else:
            self.base_url = f"https://app.{region}.sekoia.io/api"

    def request(self, method, url: str, *args, **kwargs):
        url = self.base_url.strip("/") + "/" + url.strip("/")
        res = super().request(method, url, *args, **kwargs)
        try:
            res.raise_for_status()
        except HTTPError as e:
            raise ValueError(e.response.json())
        return res

    def create_intake_key(
        self,
        entity_uuid: str,
        format_uuid: str,
        name: str,
        connector_configuration: dict | None = None,
        connector_module_configuration_uuid: str | None = None,
    ):
        """Create an intake key for the given format"""
        return self.post(
            "/v1/sic/conf/intakes",
            json=exclude_nones(
                {
                    "entity_uuid": entity_uuid,
                    "format_uuid": format_uuid,
                    "name": name,
                    "connector_configuration": connector_configuration,
                    "connector_module_configuration_uuid": connector_module_configuration_uuid,
                }
            ),
        ).json()

    def delete_intake_key(self, uuid: str):
        """Delete an intake key given its UUID"""
        return self.delete(f"/v1/sic/conf/intakes/{uuid}")

    def get_intake_keys(self, name: str | None = None, format_uuid: str | None = None):
        """Return a page of intake keys"""
        return self.get(
            "/v1/sic/conf/intakes",
            params={
                "match[name]": name,
                "match[format_uuid]": format_uuid,
            },
        ).json()["items"]

    def get_entities(self):
        """Return a page of entities"""
        return self.get("/v1/sic/conf/entities").json()["items"]

    def get_or_create_main_entity(self, default_name: str = "Main Entity"):
        """Return the main entity or create it"""
        try:
            return sorted(self.get_entities(), key=lambda x: x["entity_id"])[0]
        except IndexError:
            return self.create_entity(default_name)

    def create_entity(
        self,
        name: str,
        entity_id: str | None = None,
        alerts_generation: str | None = None,
        description: str = "Generated by Meshroom",
    ):
        """Create a new entity"""
        entity_id = entity_id or name.lower().replace(" ", "_")
        alerts_generation = alerts_generation or self.get_generation_modes()[0]["uuid"]
        return self.post(
            "/v1/sic/conf/entities",
            json={
                "entity_id": entity_id,
                "description": description,
                "alerts_generation": alerts_generation,
                "name": name,
            },
        ).json()

    def get_generation_modes(self):
        """Return the available generation modes"""
        return self.get("/v1/sic/conf/generation-modes").json()["items"]

    def get_or_create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Return a default module configuration or create it for the given module UUID"""
        try:
            return self.get_module_configurations(module_uuid)[0]
        except IndexError:
            return self.create_module_configuration(module_uuid, name, settings)

    def get_module_configurations(self, module_uuid: str):
        """Return the module configurations for the given module UUID"""
        return self.get(
            "/v1/symphony/module-configurations",
            params={
                "match[module_uuid]": module_uuid,
                "with_module": "true",
            },
        ).json()["items"]

    def create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Create a new module configuration"""
        return self.post(
            "/v1/symphony/module-configurations",
            json={
                "name": "Default",
                "module_uuid": module_uuid,
                "value": settings,
            },
        ).json()

    def list_intake_formats(self, name: str, is_custom: bool | None = None):
        """Return a list of intake formats matching the given name and is_custom status"""
        return [
            x
            for x in self.get("/v1/ingest/formats", params={"match[name]": name}).json()["items"]
            if is_custom is None or (x["community_uuid"] is not None and is_custom) or (x["community_uuid"] is None and not is_custom)
        ]

    def get_intake_format(self, uuid: str):
        """Return the intake format for the given UUID"""
        try:
            return self.get(f"/v1/ingest/formats/{uuid}")
        except Exception:
            return None

    def create_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str | None = None,
        parser: dict = {},
        slug: str | None = None,
        datasources: list[str] = [],
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Create a custom intake format"""
        f = self.post(
            "v1/ingest/formats",
            json={
                "format_uuid": uuid,
                "name": name,
                "datasources": datasources,
                "description": description or name,
                "parser": parser,
                "slug": slug or name.lower().replace(" ", "-"),
                "taxonomy": taxonomy,
                "automation_module_uuid": automation_module_uuid,
                "automation_connector_uuid": automation_connector_uuid,
            },
        ).json()
        self.post(f"v1/ingest/formats/{f['uuid']}/smart-descriptions", json={"content": smart_descriptions})
        if logo and logo.is_file():
            self.put(
                f"v1/ingest/formats/{f['uuid']}/picture",
                files={"picture": (logo.name, logo.open("rb"), "image/png")},
            )
        return f

    def update_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str,
        parser: dict = {},
        datasources: list[str] = [],
        slug: str | None = None,
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Update a custom intake format"""
        self.put(
            f"v1/ingest/formats/{uuid}",
            json={
                "name": name,
                "datasources": datasources,
                "description": description,
                "parser": parser,
                "slug": slug or name.lower().replace(" ", "-"),
                "taxonomy": taxonomy,
                "uuid": uuid,
                "automation_module_uuid": automation_module_uuid,
                "automation_connector_uuid": automation_connector_uuid,
            },
        )
        self.post(f"v1/ingest/formats/{uuid}/smart-descriptions", json={"content": smart_descriptions})
        if logo and logo.is_file():
            self.put(
                f"v1/ingest/formats/{uuid}/picture",
                files={"picture": (logo.name, logo.open("rb"), "image/png")},
            )

    def create_or_update_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str,
        parser: dict = {},
        datasources: list[str] = [],
        slug: str | None = None,
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Create or update a custom intake format"""
        if self.get_intake_format(uuid):
            return self.update_custom_intake_format(uuid, name, description, parser, datasources, slug, taxonomy, smart_descriptions, logo, automation_module_uuid, automation_connector_uuid)
        else:
            return self.create_custom_intake_format(uuid, name, description, parser, slug, datasources, taxonomy, smart_descriptions, logo, automation_module_uuid, automation_connector_uuid)

    def pull_custom_integration(self, git_url: str, branch: str = "master", path: str = "", ssh_key_id: str = None):
        """Pull a custom integration from a Git repository"""
        print(f"Pulling custom integration from Git at {git_url} /{path} branch={branch} (this can take a few minutes to build the module's docker image)")
        task_uuid = self.post(
            "/v1/symphony/modules/from-git",
            json={
                "branch": branch,
                "git": git_url,
                "path": path,
                "ssh_key_id": ssh_key_id,
            },
        ).json()["task_uuid"]
        step_status = {}
        errors = []
        while True:
            sleep(2)
            print(".", end="", flush=True)
            status = self.get(f"/v1/tasks/{task_uuid}").json()
            for s in status["attributes"]["validation_steps"]:
                if step_status.get(s["name"]) != s["status"]:
                    print(f"{s['name']}: {s['status']}")
                    if s["status"] == "failed" and s.get("error"):
                        errors.append(f"{s['error']} {s.get('output', '')}")
                step_status[s["name"]] = s["status"]
            if status.get("status") == "FAILED":
                raise RuntimeError(f"Failed to pull the custom integration: \n{'\n'.join(errors)}")
            if status.get("status") in ("SUCCESS", "FINISHED"):
                break

    def create_ssh_key(self):
        """Create an SSH key for pulling custom integrations from Git"""
        return self.post("/v1/symphony/ssh-keys/").json()
