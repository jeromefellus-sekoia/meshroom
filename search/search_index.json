{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Meshroom A command-line tool to build and manage Cybersecurity Mesh Architectures (CSMA). Philosophy As defined by Gartner, a Cybersecurity Mesh Architecture is a graph of interoperated cybersecurity services, each fulfilling a specific functional need (SIEM, EDR, EASM, XDR, TIP, etc ). Adopting the CSMA and Meshroom's philosophy means choosing an interconnected ecosystem of high-quality products with specialized scopes rather than a captive all-in-one solution. It then means : Adopting standard formats and protocols rather than proprietary ones to share data and information between products (STIX, ECS, OCSF, OpenC2, syslog, CEF, etc ) Leveraging Open APIs to make your products communicate and control eachother Exploiting products' extensibility via plugins and open-source components to encourage user-defined interoperability Who ? As a vendor : fight the N-to-N integration curse Cybersecurity vendors know it well : integrating with other cybersecurity products burns time and human resources . Integration teams feel so sad when every vendor has to spend those resources developing an integration with every other vendor, without work factorization : this is the N-to-N integration curse . This curse mostly originates from: Poor adoption of standard formats, protocols and API layouts to interoperate cybersecurity solutions Lack of open resources and documentation to start communicating and controling a given product Small actors are overwhelmed by the numerous integration opportunities with major actors, but won't factorise their contributions to make one integration suit all 3rd-party products Every actor must keep hundreds of vendor-specific integrations up to date according to hundreds of non-coordinated roadmaps and constantly breaking changes Meshroom helps cybersecurity vendors build integrations between their products and other solutions, keeping the integration burden as low a possible. To do so, meshroom comes with a set of predefined product templates categorized according to Gartner's Hype Cycle for Security Operations, 2024 that help you scaffolding full product definitions. By publishing your product's functional surface from one of this template, you encourage the adoption of open API layouts, formats and protocols. Whereby, you contributes to turn the N-to-N integration burden into an ideal repository of N reusable product definitions , where every new vendor can effortlessly plug with the N previously declared products. As a MSSP : setup a full cybersecurity mesh via declarative and versionable manifests Setting up a SOC is also a time-consuming operation. Sadly, MSSPs in charge of many similar information systems will often repeat those very same time-consuming steps again and again, switching from one solution's configuration interface to another one's admin console. Eventually, this will involve wildly manipulating API keys and admin forms, resulting in errors, security holes and blind spots. Many MSSPs maintain a run book of manual setup steps, and most of them automate part of those steps to get a SOC up-and-running within, say, days or perhaps hours... Meshroom helps DevSec operators to setup a full meshed SOC made of dozens of tenants in a single CLI command : meshroom up . Because Meshroom projects are versioned , you can push and share SOC architectures via GitHub or your favorite forge, while keeping trace of every setup and provisioning processes executed. You can think of meshroom up as the cyber mesh equivalent of Infrastructure-as-code's terraform apply or containerized stack's docker compose up . When your SOC grows to dozens of interoperated products, it becomes hard to visualize where data and controls flow between them. Meshroom provides an easy to use graph model documenting: all capabilities exposed by the products you are using all available integrations they offer to other products all the active connections (know as Plugs within Meshroom) between products (aka producer / consumer and trigger / executor relationships) As a developer : painless DX to build and publish custom product additions Many cybersecurity platforms offer extensibility capabilities via plugins , custom formats, custom rules, custom actions, etc . Here again, there's no accepted standard and every vendor defines its own approach (YAML files, python code, no-code workflows, etc ). Yet, products interoperability often rely on contributing custom additions to one or both ends. Of course, this scope is often badly documented, and developers are left with trial-and-error quasi-reverse ninja approaches to understand how to make product A talk to product B. In the end, you'll eventually succeed in getting a working plugin, but then face the un-coordinated maze of homologation processes each vendor mandates to make your contribution public . Meshroom helps cybersecurity vendors to expose a single standard contribution model for: setting up custom software additions when interoperability mandates so compiling everything into a product plugin suitable for publication publishing as a PR to GitHub or other marketplaces Meshroom also eases the tedious \"playground\" phase where developers need to send test data to their trial 3rd-party instances, trigger remote commands from their workstation, watch results, make changes to their integration in an agile continous development workflow: meshroom produce helps you sending data through plugged integrations meshroom watch helps you watching data flowing through a plugged integration","title":"Meshroom"},{"location":"#meshroom","text":"A command-line tool to build and manage Cybersecurity Mesh Architectures (CSMA).","title":"Meshroom"},{"location":"#philosophy","text":"As defined by Gartner, a Cybersecurity Mesh Architecture is a graph of interoperated cybersecurity services, each fulfilling a specific functional need (SIEM, EDR, EASM, XDR, TIP, etc ). Adopting the CSMA and Meshroom's philosophy means choosing an interconnected ecosystem of high-quality products with specialized scopes rather than a captive all-in-one solution. It then means : Adopting standard formats and protocols rather than proprietary ones to share data and information between products (STIX, ECS, OCSF, OpenC2, syslog, CEF, etc ) Leveraging Open APIs to make your products communicate and control eachother Exploiting products' extensibility via plugins and open-source components to encourage user-defined interoperability","title":"Philosophy"},{"location":"#who","text":"","title":"Who ?"},{"location":"#as-a-vendor-fight-the-n-to-n-integration-curse","text":"Cybersecurity vendors know it well : integrating with other cybersecurity products burns time and human resources . Integration teams feel so sad when every vendor has to spend those resources developing an integration with every other vendor, without work factorization : this is the N-to-N integration curse . This curse mostly originates from: Poor adoption of standard formats, protocols and API layouts to interoperate cybersecurity solutions Lack of open resources and documentation to start communicating and controling a given product Small actors are overwhelmed by the numerous integration opportunities with major actors, but won't factorise their contributions to make one integration suit all 3rd-party products Every actor must keep hundreds of vendor-specific integrations up to date according to hundreds of non-coordinated roadmaps and constantly breaking changes Meshroom helps cybersecurity vendors build integrations between their products and other solutions, keeping the integration burden as low a possible. To do so, meshroom comes with a set of predefined product templates categorized according to Gartner's Hype Cycle for Security Operations, 2024 that help you scaffolding full product definitions. By publishing your product's functional surface from one of this template, you encourage the adoption of open API layouts, formats and protocols. Whereby, you contributes to turn the N-to-N integration burden into an ideal repository of N reusable product definitions , where every new vendor can effortlessly plug with the N previously declared products.","title":"As a vendor : fight the N-to-N integration curse"},{"location":"#as-a-mssp-setup-a-full-cybersecurity-mesh-via-declarative-and-versionable-manifests","text":"Setting up a SOC is also a time-consuming operation. Sadly, MSSPs in charge of many similar information systems will often repeat those very same time-consuming steps again and again, switching from one solution's configuration interface to another one's admin console. Eventually, this will involve wildly manipulating API keys and admin forms, resulting in errors, security holes and blind spots. Many MSSPs maintain a run book of manual setup steps, and most of them automate part of those steps to get a SOC up-and-running within, say, days or perhaps hours... Meshroom helps DevSec operators to setup a full meshed SOC made of dozens of tenants in a single CLI command : meshroom up . Because Meshroom projects are versioned , you can push and share SOC architectures via GitHub or your favorite forge, while keeping trace of every setup and provisioning processes executed. You can think of meshroom up as the cyber mesh equivalent of Infrastructure-as-code's terraform apply or containerized stack's docker compose up . When your SOC grows to dozens of interoperated products, it becomes hard to visualize where data and controls flow between them. Meshroom provides an easy to use graph model documenting: all capabilities exposed by the products you are using all available integrations they offer to other products all the active connections (know as Plugs within Meshroom) between products (aka producer / consumer and trigger / executor relationships)","title":"As a MSSP : setup a full cybersecurity mesh via declarative and versionable manifests"},{"location":"#as-a-developer-painless-dx-to-build-and-publish-custom-product-additions","text":"Many cybersecurity platforms offer extensibility capabilities via plugins , custom formats, custom rules, custom actions, etc . Here again, there's no accepted standard and every vendor defines its own approach (YAML files, python code, no-code workflows, etc ). Yet, products interoperability often rely on contributing custom additions to one or both ends. Of course, this scope is often badly documented, and developers are left with trial-and-error quasi-reverse ninja approaches to understand how to make product A talk to product B. In the end, you'll eventually succeed in getting a working plugin, but then face the un-coordinated maze of homologation processes each vendor mandates to make your contribution public . Meshroom helps cybersecurity vendors to expose a single standard contribution model for: setting up custom software additions when interoperability mandates so compiling everything into a product plugin suitable for publication publishing as a PR to GitHub or other marketplaces Meshroom also eases the tedious \"playground\" phase where developers need to send test data to their trial 3rd-party instances, trigger remote commands from their workstation, watch results, make changes to their integration in an agile continous development workflow: meshroom produce helps you sending data through plugged integrations meshroom watch helps you watching data flowing through a plugged integration","title":"As a developer : painless DX to build and publish custom product additions"},{"location":"concepts/","text":"Concepts Integration lifecycle TODO CYCLE SCHEMA Capabilities graph Formally, a cybersecurity mesh architecture (CSMA) is a directed graph of products talking to eachother. More precisely, it is an overlay of 2 graphs: The capabilities graph , which expresses the set of all products that can be interoperated with eachother and what functional capacity they expose. Nodes of this graph are Product capabilities, and edges connect complementary capabilities. For example, one product may consume alerts produced by another product, or can execute actions triggered by another one. Edges thus characterise interop opportunities about a certain Topic between a source product and a destination product. The direction of the edges materializes the dataflow : the source product produces/triggers information (resp. actions) that the destination product consumes/executes . An edge exists as soon as the products define a compatible producer (or trigger) / consumer (resp. executor) pair of Integrations . The edge also carries the roles in the data exchange in push mode, the producer is active and the consumer is passive ( e.g. a Syslog forwarder) in pull mode, the producer is passive and the consumer is active ( e.g. an HTTP GET API) Therefore, an edge exist between product couples that expose complementary integrations for compatible topics, and match formats or other compatibility criteria you may need to refine the scope of a capability. The density if the capabilities graph measures the \"openness\" of the products constellation ; one wants to maximize the number of allowed interops between cybersecurity solutions available on the market The Mesh graph itself, which is an instanciation of several product Instances connected to eachother by Plugs who leverage compatible Integrations over the underlying capabilities graph. Instances correspond to actual user tenants of the underlying products, and plugs are live connections between those tenants. In order to setup the defined plugs, instances must be configured to enable the corresponding production/consumption triggering/execution logic, potentially via custom additions to the products themselves. Meshroom's spirit is to make all this configuration and provisioning as simple as a single meshroom up command. To do so, Products, Integrations, Instances and Plugs are defined via YAML manifests and vendor code additions when required. All these files belong to a git-backed repository that can be shared, versioned via git and manipulated via the Meshroom CLI, exactly as, say, Helm charts can be shared among a community of Kubernetes users. Some sensitive data , like API keys and other secrets used to teleoperate the Instances are natively held and managed by Meshroom in a local GPG secrets store , that can also be shared following a classical GPG assymetric cryptography process. This decreases the risk of leak resulting from a spread of secrets used to co-ordinate numerous tenants, while easing the sharing of a full read-to-use SOC configuration. Product meshroom create product meshroom list products Integration meshroom create integration meshroom list integrations Instance meshroom add meshroom list instances meshroom configure secrets GPG Plug meshroom plug meshroom unplug meshroom list plugs Up/down meshroom up meshroom down Hooks setup teardown scaffold pull publish produce watch Meshroom project structure A Meshroom project is a git-backed directory on your computer, that you can version and share via your favorite online git service. The local project itself has the following structure: \u2503 \u2523\u2501 products \ud83e\udfa4\u2501\u2501\u2501 All products available in the capabilities graph \u2503 \u2517\u2501 product_a \u2503 \u2523\u2501 definition.yaml \ud83e\udfa4\u2501\u2501\u2501 Define capabilities of product_a \u2503 \u2523\u2501 setup.py \ud83e\udfa4\u2501\u2501\u2501 Various python files with generic hooks for product_a's integrations \u2503 \u2517\u2501 integrations \ud83e\udfa4\u2501\u2501\u2501 All integration offered by product_a \u2503 \u2517\u2501 product_b \ud83e\udfa4\u2501\u2501\u2501 All integration offered by product_a with product_b \u2503 \u2523\u2501 events_consumer.yaml \ud83e\udfa4\u2501\u2501\u2501 An integration product_a -[events]-> product_b in push mode \u2503 \u2523\u2501 events_consumer.py \ud83e\udfa4\u2501\u2501\u2501 Hooks for the above integration \u2503 \u2523\u2501 events_consumer_pull.yaml \ud83e\udfa4\u2501\u2501\u2501 An integration product_a -[events]-> product_b in pull mode \u2503 \u2517\u2501 events_consumer_pull.py \ud83e\udfa4\u2501\u2501\u2501 Hooks for this latter integration \u2503 \u2517\u2501 product_b \u2503 \u2517\u2501 ... \ud83e\udfa4\u2501\u2501\u2501 same structure for each product... \u2503 \u2523\u2501 instances \ud83e\udfa4\u2501\u2501\u2501 Define the instances used in this project's mesh \u2503 \u2517\u2501 product_a \ud83e\udfa4\u2501\u2501\u2501 Instances for product_a \u2503 \u2517\u2501 instance_a \ud83e\udfa4\u2501\u2501\u2501 Some product_a's instance, here called \"instance_a\" \u2503 \u2523\u2501 config.yaml \ud83e\udfa4\u2501\u2501\u2501 Non-sensitive configuration for instance_a \u2503 \u2517\u2501 plugs \ud83e\udfa4\u2501\u2501\u2501 Plugs whose source is instance_a \u2503 \u2517\u2501 instance_b \ud83e\udfa4\u2501\u2501\u2501 Plugs whose destination is instance_b \u2503 \u2517\u2501 event_consumer_pull.yaml \ud83e\udfa4\u2501\u2501\u2501 Config for plug instance_a -[events]-> instance_b in pull mode \u2503 \u2517\u2501 product_b \u2503 \u2517\u2501 instance_product_b \u2503 \u2517\u2501 ... \u2523\u2501 secrets.gpg \ud83e\udfa4\u2501\u2501\u2501 GPG-encrypted store of all instances' secrets This is a minimal example, your project may contain additional files, such as .gitignore, README.md and other documentation or scripts for automating stuff.","title":"Concepts"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/#integration-lifecycle","text":"TODO CYCLE SCHEMA","title":"Integration lifecycle"},{"location":"concepts/#capabilities-graph","text":"Formally, a cybersecurity mesh architecture (CSMA) is a directed graph of products talking to eachother. More precisely, it is an overlay of 2 graphs: The capabilities graph , which expresses the set of all products that can be interoperated with eachother and what functional capacity they expose. Nodes of this graph are Product capabilities, and edges connect complementary capabilities. For example, one product may consume alerts produced by another product, or can execute actions triggered by another one. Edges thus characterise interop opportunities about a certain Topic between a source product and a destination product. The direction of the edges materializes the dataflow : the source product produces/triggers information (resp. actions) that the destination product consumes/executes . An edge exists as soon as the products define a compatible producer (or trigger) / consumer (resp. executor) pair of Integrations . The edge also carries the roles in the data exchange in push mode, the producer is active and the consumer is passive ( e.g. a Syslog forwarder) in pull mode, the producer is passive and the consumer is active ( e.g. an HTTP GET API) Therefore, an edge exist between product couples that expose complementary integrations for compatible topics, and match formats or other compatibility criteria you may need to refine the scope of a capability. The density if the capabilities graph measures the \"openness\" of the products constellation ; one wants to maximize the number of allowed interops between cybersecurity solutions available on the market The Mesh graph itself, which is an instanciation of several product Instances connected to eachother by Plugs who leverage compatible Integrations over the underlying capabilities graph. Instances correspond to actual user tenants of the underlying products, and plugs are live connections between those tenants. In order to setup the defined plugs, instances must be configured to enable the corresponding production/consumption triggering/execution logic, potentially via custom additions to the products themselves. Meshroom's spirit is to make all this configuration and provisioning as simple as a single meshroom up command. To do so, Products, Integrations, Instances and Plugs are defined via YAML manifests and vendor code additions when required. All these files belong to a git-backed repository that can be shared, versioned via git and manipulated via the Meshroom CLI, exactly as, say, Helm charts can be shared among a community of Kubernetes users. Some sensitive data , like API keys and other secrets used to teleoperate the Instances are natively held and managed by Meshroom in a local GPG secrets store , that can also be shared following a classical GPG assymetric cryptography process. This decreases the risk of leak resulting from a spread of secrets used to co-ordinate numerous tenants, while easing the sharing of a full read-to-use SOC configuration.","title":"Capabilities graph"},{"location":"concepts/#product","text":"meshroom create product meshroom list products","title":"Product"},{"location":"concepts/#integration","text":"meshroom create integration meshroom list integrations","title":"Integration"},{"location":"concepts/#instance","text":"meshroom add meshroom list instances meshroom configure secrets GPG","title":"Instance"},{"location":"concepts/#plug","text":"meshroom plug meshroom unplug meshroom list plugs","title":"Plug"},{"location":"concepts/#updown","text":"meshroom up meshroom down","title":"Up/down"},{"location":"concepts/#hooks","text":"setup teardown scaffold pull publish produce watch","title":"Hooks"},{"location":"concepts/#meshroom-project-structure","text":"A Meshroom project is a git-backed directory on your computer, that you can version and share via your favorite online git service. The local project itself has the following structure: \u2503 \u2523\u2501 products \ud83e\udfa4\u2501\u2501\u2501 All products available in the capabilities graph \u2503 \u2517\u2501 product_a \u2503 \u2523\u2501 definition.yaml \ud83e\udfa4\u2501\u2501\u2501 Define capabilities of product_a \u2503 \u2523\u2501 setup.py \ud83e\udfa4\u2501\u2501\u2501 Various python files with generic hooks for product_a's integrations \u2503 \u2517\u2501 integrations \ud83e\udfa4\u2501\u2501\u2501 All integration offered by product_a \u2503 \u2517\u2501 product_b \ud83e\udfa4\u2501\u2501\u2501 All integration offered by product_a with product_b \u2503 \u2523\u2501 events_consumer.yaml \ud83e\udfa4\u2501\u2501\u2501 An integration product_a -[events]-> product_b in push mode \u2503 \u2523\u2501 events_consumer.py \ud83e\udfa4\u2501\u2501\u2501 Hooks for the above integration \u2503 \u2523\u2501 events_consumer_pull.yaml \ud83e\udfa4\u2501\u2501\u2501 An integration product_a -[events]-> product_b in pull mode \u2503 \u2517\u2501 events_consumer_pull.py \ud83e\udfa4\u2501\u2501\u2501 Hooks for this latter integration \u2503 \u2517\u2501 product_b \u2503 \u2517\u2501 ... \ud83e\udfa4\u2501\u2501\u2501 same structure for each product... \u2503 \u2523\u2501 instances \ud83e\udfa4\u2501\u2501\u2501 Define the instances used in this project's mesh \u2503 \u2517\u2501 product_a \ud83e\udfa4\u2501\u2501\u2501 Instances for product_a \u2503 \u2517\u2501 instance_a \ud83e\udfa4\u2501\u2501\u2501 Some product_a's instance, here called \"instance_a\" \u2503 \u2523\u2501 config.yaml \ud83e\udfa4\u2501\u2501\u2501 Non-sensitive configuration for instance_a \u2503 \u2517\u2501 plugs \ud83e\udfa4\u2501\u2501\u2501 Plugs whose source is instance_a \u2503 \u2517\u2501 instance_b \ud83e\udfa4\u2501\u2501\u2501 Plugs whose destination is instance_b \u2503 \u2517\u2501 event_consumer_pull.yaml \ud83e\udfa4\u2501\u2501\u2501 Config for plug instance_a -[events]-> instance_b in pull mode \u2503 \u2517\u2501 product_b \u2503 \u2517\u2501 instance_product_b \u2503 \u2517\u2501 ... \u2523\u2501 secrets.gpg \ud83e\udfa4\u2501\u2501\u2501 GPG-encrypted store of all instances' secrets This is a minimal example, your project may contain additional files, such as .gitignore, README.md and other documentation or scripts for automating stuff.","title":"Meshroom project structure"},{"location":"commands/create_product/","text":"meshroom create product","title":"meshroom create product"},{"location":"commands/create_product/#meshroom-create-product","text":"","title":"meshroom create product"},{"location":"concepts/introduction/","text":"","title":"Introduction"}]}